<!--yml
category: 蓝桥杯
date: 2022-04-26 11:23:48
-->

# 2013年第四届C B组蓝桥杯省赛真题_元气算法的博客-CSDN博客

> 来源：[https://blog.csdn.net/kiwi_berrys/article/details/111242234](https://blog.csdn.net/kiwi_berrys/article/details/111242234)

> 这里是蓝桥杯历年的题目专栏，将会陆续更新将往年真题以及解答发布出来，欢迎各位小伙伴关注我吖，你们的点赞关注就是给我最好的动力！！！
> <font>每天更新一届真题，敬请期待</font>

[全网最全蓝桥杯历年真题及详细解答](https://blog.csdn.net/kiwi_berrys/article/details/111186204)

### 第一题：高斯日记（4分）

**题目描述**
大数学家高斯有个好习惯：无论如何都要记日记。他的日记有个与众不同的地方，他从不注明年月日，而是用一个整数代替，比如：4210。后来人们知道，那个整数就是日期，它表示那一天是高斯出生后的第几天。这或许也是个好习惯，它时时刻刻提醒着主人：日子又过去一天，还有多少时光可以用于浪费呢？
高斯出生于1777年4月30日，在高斯发现的一个重要定理的日记上标注着5343，因此可算出那天是1791年12月15日。高斯获得博士学位的那天日记上标着8113，请你算出高斯获得博士学位的年月日。
提交答案的格式是：yyyy-mm-dd，例如：1980-03-21
**题目分析**
首先确定发生事件的年份，就是用总的天数减去每年天数
然后确定在该年的月份以及日期。
**题目代码**

```
#include<iostream>

using namespace std;

bool jude(int year)
{
	return year%400==0 || ((year%100) && year%4==0);

}
int main()
{
	int n;
	cin >> n;

	int sumDay = n + 31 + 28 + 31 + 30 - 1;

	int days[13] = {0,31,28,31,30,31,30,31,31,30,31,30,31};
	int year = 1777,month = 4,day = 30;
	int m;

	while(1)
	{
		int yearday = 0;
		if(jude(year))
			yearday = 366;
		else 
			yearday = 365;
		if(sumDay<yearday)
		{
			break;
		}
		sumDay -= yearday;
		year++;
	}

	if(jude(year))
		days[2] = 29;
	else
		days[2] = 28;

	for(int i =1; i < 13; i++)
	{
		if(sumDay<=days[i])
		{

			cout << year<<"-" ;
			if(i<10)
				cout << "0";
			cout << i;
			if(sumDay<0)
				cout <<"0";
			cout << "-"<<sumDay;
			return 0;
		}
		sumDay -= days[i];
	}
	return 0;
} 
```

**题目答案**

```
1799-07-16 
```

### 第二题：马虎的算式（5分）

**题目描述**
小明是个急性子，上小学的时候经常把老师写在黑板上的题目抄错了。有一次，老师出的题目是：36*495=？他却给抄成了：396*45=?但结果却很戏剧性，他的答案竟然是对的！
因为36*495=396*45=17820，类似的巧合情况可能还有很多，比如：27*594=297*54。假设a b c d e代表1~9不同的5个数字（注意是各不相同的数字，且不含0），能满足形如：ab*cde=adb*ce这样的算式一共有多少种呢？
请你利用计算机的优势寻找所有的可能，并回答不同算式的种类数。满足乘法交换律的算式计为不同的种类，所以答案肯定是个偶数。

**题目分析**
这题蓝桥杯的特性:暴力杯，直接五层循环输出就可以。
也可使用递归，建议平常多使用递归练手
**题目代码**

```
#include<iostream>
using namespace std;

int main()
{
	int ans = 0;
	for(int a = 1; a <= 9; a++)
	{
		for(int b = 1; b <= 9; b++)
		{
			if(a!=b)
			for(int c =1; c <= 9; c++)
			{	
				if(c!=b&&c!=a)
				for(int d =1; d <= 9; d++)
				{	
					if(d!=c&&d!=b&&d!=a)
					for(int e =1; e <= 9; e++)
					{
						if(e!=d&&e!=c&&e!=b&&e!=a)
						{
							int left = (a*10+b) * (c*100+d*10+e);
							int right = (a*100+d*10+b) * (c*10+e); 
							if(left == right)
							{
								ans++;
							}
						}
					}
				}
			}
		}
	}
	cout << ans;
	return 0;	
} 
```

**题目答案**

```
142 
```

### 第三题：第39级台阶（8分）

**题目描述**
小明刚刚看完电影《第39级台阶》，离开电影院的时候，他数了数礼堂前的台阶数，恰好是39级！站在台阶前，他突然又想着一个问题：
如果我每一步只能迈上1个或2个台阶，先迈左脚，然后左右交替，最后一步是迈右脚，也就是说一共要走偶数步。那么，上完39级台阶，有多少种不同的上法呢？
请你利用计算机的优势，帮助小明寻找答案。要求提交的是一个整数。

**题目分析**
这题使用递归算法
递归的终止条件：当步数达到39时候，终止递归
递归的两个入口：单步上台阶，和两步上台阶
**题目代码**

```
#include<iostream>

using namespace std;

int DFS(int num,int time)
{
	if(num>39)
	{
		return 0;
	}
	if(num==39)
	{
		if(time%2==0)
		{
			return 1;
		}
		return 0;
	}

	return DFS(num+1,time+1)+DFS(num+2,time+1);

}
int main()
{
	int ans = DFS(1,1)+DFS(2,1); 
	cout << ans;
	return 0; 
} 
```

### 第四题：黄金连分数（12分）

**题目描述**
黄金分割数0.61803…是个无理数，这个常数十分重要，在许多工程问题中会出现。有时需要把这个数字求得很精确。
对于某些精密工程，常数的精度很重要。也许你听说过哈勃太空望远镜，它首次升空后就发现了一处人工加工错误，对那样一个庞然大物，其实只是镜面加工时有比头发丝还细许多倍的一处错误而已，却使它成了“近视眼”！
言归正传，我们如何求得黄金分割数的尽可能精确的值呢？有许多方法。
比较简单的一种是用连分数：

```
                 1
    黄金数 = ---------------------
                     1
             1 + -----------------
                        1
                 1 + -------------
                           1
                     1 + ---------
                          1 + ...

```

这个连分数计算的“层数”越多，它的值越接近黄金分割数。请你利用这一特性，求出黄金分割数的足够精确值，要求四舍五入到小数点后100位。
小数点后3位的值为：0.618
小数点后4位的值为：0.6180
小数点后5位的值为：0.61803
小数点后7位的值为：0.6180340
（注意尾部的0，不能忽略）
你的任务是：写出精确到小数点后100位精度的黄金分割值。注意：尾数的四舍五入！ 尾数是0也要保留！显然答案是一个小数，其小数点后有100位数字。

**题目分析**
就是可以发现为 1/2 2/3 3/5 .。。。发现这是斐波那契数列，前一项除以后一项，然后我们把除出来的数保存就可
**题目代码**

```
#include<iostream>
using namespace std;

unsigned long long ans[100] = {0,1,1,2};

int main()
{
    for( int i = 3; i < 90; i++ )
        ans[i] = ans[i-1] + ans[i-2];
    unsigned long long x = ans[80], y = ans[81];
    for( int i = 0; i < 100; i++ )
    {
        cout << x/y;
        x = (x%y)*10;
    }
    return 0;
} 
```

**题目答案**

```
0618033988749894848204586834365637806199342618022749702241907684204945739336382682315131422629959486 
```

### 第五题：前缀判断（5分）

**题目描述**
如下的代码判断needle_start指向的串是否为haystack_start指向的串的前缀，如不是，则返回NULL。比如："abcd1234"就包含了"abc"为前缀。

```
char *prefix(char *haystack_start,char *needle_start)
{ 
	char *haystack=haystack_start;
	char *needle=needle_start;
	while(*haystack&&*needle)
	{
		if(_____________________) return NULL;  
	}
	if(*needle) return NULL;
	return haystack_start;
} 
```

**题目分析**
我们可以发现 haystack为要判断的字符串，而needle是前缀。就是对于两个字符串比较。，指针加一
**题目代码**

```
#include<iostream>
using namespace std;

char *prefix(char *haystack_start,char *needle_start)
{ 
	char *haystack=haystack_start;
	char *needle=needle_start;
	while(*haystack&&*needle)
	{
		if(*(haystack++)!=*(needle++)) return NULL;  
	}
	if(*needle) return NULL;
	return haystack_start;
}
int main()
{
	char haystack_start[] = "abcd123";
	char needle_start[] = "abcd";
	char *ans = prefix(haystack_start,needle_start);
	cout <<ans;
} 
```

**题目答案**

```
*(haystack++)!=*(needle++) 
```

### 第六题：三部排序（7分）

**题目描述**
        一般的排序有许多经典算法，如快速排序、希尔排序等。但实际应用时，经常会或多或少有一些特殊要求。我们没必要套用那些经典算法，可以根据实际情况建立更好的解法。
        比如，对一个整型数组中的数字进行分类排序：使得负数都靠左端，正数都靠右端，0在中部。注意问题的特点是：负数区域和正数区域内并不要求有序。可以利用这个特点通过1次线性扫描就结束战斗！
        以下的程序实现了该目标。其中x指向待排序的整型数组，len是数组的长度。

```
#include <stdio.h>
void sort3p(int *x,int len)
{ 
	int p=0;
	int left=0;
 	int right=len-1;
 	int t;
 	while(p<=right)
    { 
    	if(x[p]<0)
        { 
        	t=x[left];  x[left]=x[p];  x[p]=t;  left++;  p++; 
       	}
	  	else if(x[p]>0) 
	  	{ 
	  		t=x[right];  x[right]=x[p];  x[p]=t;  right--; 
	  	}
		else 
		{ 
			_______________________
		}
	}
} 
```

**题目分析**
,第一步是遍历下标p，第二步是最左下标left和最右下标right，第三步，利用p遍历，遍历的过程中，如果有小于0的则与下标为left的x[left]进行交换，如果有大于0的则与下标为right的x[right]进行交换
**题目代码**

```
#include <stdio.h>
void sort3p(int *x,int len)
{ 
	int p=0;
	int left=0;
 	int right=len-1;
 	int t;
 	while(p<=right)
    { 
    	if(x[p]<0)
        { 
        	t=x[left];  x[left]=x[p];  x[p]=t;  left++;  p++; 
       	}
	  	else if(x[p]>0) 
	  	{ 
	  		t=x[right];  x[right]=x[p];  x[p]=t;  right--; 
	  	}
		else 
		{ 
			x[p++]=0
		}
	}
} 
```

**题目答案**

```
x[p++]=0 
```

### 第七题：错误票据（4分）

**题目描述**
某涉密单位下发了某种票据，并要在年终全部收回。每张票据有唯一的ID号，全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。你的任务是通过编程，找出断号的ID和重号的ID，假设断号不可能发生在最大和最小号。要求程序首先输入一个整数N（N<100）表示后面数据行数，接着读入N行数据，每行数据长度不等，是用空格分开的若干个（不大于100个）正整数（不大于100000），每个整数代表一个ID号。要求程序输出1行，含两个整数m n，用空格分隔，其中，m表示断号ID，n表示重号ID。
例如，用户输入：
2
5 6 8 11 9
10 12 9
则程序输出：
7 9
再例如，用户输入：
6
164 178 108 109 180 155 141 159 104 182 179 118 137 184 115 124 125 129 168 196
172 189 127 107 112 192 103 131 133 169 158
128 102 110 148 139 157 140 195 197
185 152 135 106 123 173 122 136 174 191 145 116 151 143 175 120 161 134 162 190
149 138 142 146 199 126 165 156 153 193 144 166 170 121 171 132 101 194 187 188
113 130 176 154 177 120 117 150 114 183 186 181 100 163 160 167 147 198 111 119
则程序输出：
105 120

**题目分析**
**题目代码**

### 第八题：翻硬币（10分）

**题目描述**

```
小明正在玩一个“翻硬币”的游戏。桌上放着排成一排的若干硬币。我们用*表示正面，用o表示反面（是小写字母，不是零），比如可能情形是**oo***oooo，如果同时翻转左边的两个硬币，则变为oooo***oooo。现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币，那么对特定的局面，最少要翻动多少次呢？
我们约定：把翻动相邻的两个硬币叫做一步操作，要求：
程序输入：两行等长字符串，分别表示初始状态和要达到的目标状态，每行长度<1000
程序输出：一个整数，表示最小操作步数。
例如，用户输入：
**********
o****o****
程序应该输出：5
再例如，用户输入：
*o**o***o***
*o***o**o***
程序应该输出：1

```

**题目分析**
**题目代码**

### 第九题：带分数（16分）

**题目描述**
100可以表示为带分数的形式：100=3+69258/714，还可以表示为：100=82+3546/197，注意特征：带分数中，数字1~9分别出现且只出现一次（不包含0）。类似这样的带分数，100有11种表示法。
题目要求：从标准输入读入一个正整数N（N<1000*1000）程序输出该数字用数码1~9不重复不遗漏地组成带分数表示的全部种数。注意：不要求输出每个表示，只统计有多少表示法！
例如，用户输入：100
程序输出：11
再例如，用户输入：105
程序输出：6

**题目分析**
**题目代码**

### 第十题：连号区间数（29分）

**题目描述**
小明这些天一直在思考这样一个奇怪而有趣的问题：在1~N的某个全排列中有多少个连号区间呢？这里所说的连号区间的定义是：如果区间[L,R]里的所有元素（即此排列的第L个到第R个元素）递增排序后能得到一个长度为R-L+1的“连续”数列，则称这个区间连号区间。
当N很小的时候，小明可以很快地算出答案，但是当N变大的时候，问题就不是那么简单了，现在小明需要你的帮助。
输入格式：
第一行是一个正整数N（1<=N<=50000），表示全排列的规模；
第二行是N个不同的数字Pi（1<=Pi<=N），表示这N个数字的某一全排列。
输出格式：输出一个整数，表示不同连号区间的数目。
示例，用户输入：
4
3 2 4 1
程序应输出：7
用户输入：
5
3 4 2 5 1
程序应输出：9
解释：
第一个用例中，有7个连号区间分别是：[1,1],[1,2],[1,3],[1,4],[2,2],[3,3],[4,4]
第二个用例中，有9个连号区间分别是：[1,1],[1,2],[1,3],[1,4],[1,5],[2,2],[3,3],[4,4],[5,5]

**题目分析**
**题目代码**