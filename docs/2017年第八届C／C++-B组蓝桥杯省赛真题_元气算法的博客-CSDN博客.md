<!--yml
category: 蓝桥杯
date: 2022-04-26 11:23:57
-->

# 2017年第八届C/C++ B组蓝桥杯省赛真题_元气算法的博客-CSDN博客

> 来源：[https://blog.csdn.net/kiwi_berrys/article/details/111257161](https://blog.csdn.net/kiwi_berrys/article/details/111257161)

> 这里是蓝桥杯历年的题目专栏，将会陆续更新将往年真题以及解答发布出来，欢迎各位小伙伴关注我吖，你们的点赞关注就是给我最好的动力！！！
> <font>每天更新一届真题，敬请期待</font>

[蓝桥杯历年真题及详细解答](https://blog.csdn.net/kiwi_berrys/article/details/111186204)

### 第一题：购物单(5分)

**题目描述**
小明刚刚找到工作，老板人很好，只是老板夫人很爱购物。老板忙的时候经常让小明帮忙到商场代为购物。小明很厌烦，但又不好推辞。
这不，XX大促销又来了！老板夫人开出了长长的购物单，都是有打折优惠的。小明也有个怪癖，不到万不得已，从不刷卡，直接现金搞定。现在小明很心烦，请你帮他计算一下，需要从取款机上取多少现金，才能搞定这次购物。
取款机只能提供100元面额的纸币。小明想尽可能少取些现金，够用就行了。 你的任务是计算出，小明最少需要取多少现金。以下是让人头疼的购物单，为了保护隐私，物品名称被隐藏了。

* * *

```
****     180.90       88 
****      10.25       65
****      56.14       90
****     104.65       90
****     100.30       80
****     297.15       50
****      26.75       65
****     130.62       50
****     240.28       58
****     270.62       80
****     115.87       88
****     247.34       95
****      73.21       90
****     101.00       50
****      79.54       50
****     278.44       70
****     199.26       50
****      12.97       90
****     166.30       78
****     125.50       58
****      84.98       90
****     113.35       68
****     166.57       50
****      42.56       90
****      81.90       95
****     131.78       80
****     255.89       78
****     109.17       90
****     146.69       68
****     139.33       65
****     141.16       78
****     154.74       80
****      59.42       80
****      85.44       68
****     293.70       88
****     261.79       65
****      11.30       88
****     268.27       58
****     128.29       88
****     251.03       80
****     208.39       75
****     128.88       75
****      62.06       90
****     225.87       75
****      12.89       75
****      34.28       75
****      62.16       58
****     129.12       50
****     218.37       50
****     289.69       80

```

* * *

需要说明的是，88折指的是按标价的88%计算，而8折是按80%计算，余者类推。
特别地，半价是按50%计算。
请提交小明要从取款机上提取的金额，单位是元。
答案是一个整数，类似4300的样子，结尾必然是00，不要填写任何多余的内容。
特别提醒：不许携带计算器入场，也不能打开手机。

**题目分析**
使用scanf读取数据，使用ctr+z终止读取数据
**题目代码**

```
#include<iostream>
#include<stdio.h>

using namespace std;

int main()
{
	float a;
	int b;
	float sum = 0;
	while(scanf("**** %f %d\n",&a,&b))
	{
		sum += a*b/100; 
	}
	printf("%f",sum);
} 
```

**题目答案**

```
5200 
```

### 第二题：等差素数列（7分）

**题目描述**
2,3,5,7,11,13,…是素数序列。
类似：7,37,67,97,127,157 这样完全由素数组成的等差数列，叫等差素数数列。
上边的数列公差为30，长度为6。
2004年，格林与华人陶哲轩合作证明了：存在任意长度的素数等差数列。
这是数论领域一项惊人的成果！
有这一理论为基础，请你借助手中的计算机，满怀信心地搜索：
长度为10的等差素数列，其公差最小值是多少？
注意：需要提交的是一个整数，不要填写任何多余的内容和说明文字。

**题目分析**
暴力解题，使用三层循环
**题目代码**

```
#include<iostream>
using namespace std;
long  long int prime[100019];
bool  isprime( long long int n){
	  for( long long int i=2;i*i<=n;i++)
	       if( n % i == 0)
		       return false;
      return true;			    
} 
int   main(void){ 
      for( long long int i=2;i<=100009;i++)       
	       if( isprime(i) )
		       prime[i] =1; 

	  for( int i=1;i<=1000;i++)                
	       for( int j=1;j<=8000;j++ ){         
	                int flag=0; 
	       	        for( int k=1; k<=9 ;k++){
	       	        	 if( prime[j + k*i] == 0){
	       	        	 	 flag=1;
	       	        	 	 break;
							}

					   }  
		            if( !flag ){ 
					    printf("%d\n",i);
					    return 0 ;	 
					}
		   }

	  return 0;
} 
```

**题目答案**

```
210 
```

### 第三题：承压计算(13分)

**题目描述**
X星球的高科技实验室中整齐地堆放着某批珍贵金属原料。
每块金属原料的外形、尺寸完全一致，但重量不同。
金属材料被严格地堆放成金字塔形。

```
 7
                            5 8
                           7 8 8
                          9 2 7 2
                         8 1 4 9 1
                        8 1 8 8 4 1
                       7 9 6 1 4 5 4
                      5 6 5 5 6 9 5 6
                     5 5 4 7 9 3 5 5 1
                    7 5 7 9 7 4 7 3 3 1
                   4 6 4 5 5 8 8 3 2 4 3
                  1 1 3 3 1 6 6 5 5 4 4 2
                 9 9 9 2 1 9 1 9 2 9 5 7 9
                4 3 3 7 7 9 3 6 1 3 8 8 3 7
               3 6 8 1 5 3 9 5 8 3 8 1 8 3 3
              8 3 2 3 3 5 5 8 5 4 2 8 6 7 6 9
             8 1 8 1 8 4 6 2 2 1 7 9 4 2 3 3 4
            2 8 4 2 2 9 9 2 8 3 4 9 6 3 9 4 6 9
           7 9 7 4 9 7 6 6 2 8 9 4 1 8 1 7 2 1 6
          9 2 8 6 4 2 7 9 5 4 1 2 5 1 7 3 9 8 3 3
         5 2 1 6 7 9 3 2 8 9 5 5 6 6 6 2 1 8 7 9 9
        6 7 1 8 8 7 5 3 6 5 4 7 3 4 6 7 8 1 3 2 7 4
       2 2 6 3 5 3 4 9 2 4 5 7 6 6 3 2 7 2 4 8 5 5 4
      7 4 4 5 8 3 3 8 1 8 6 3 2 1 6 2 6 4 6 3 8 2 9 6
     1 2 4 1 3 3 5 3 4 9 6 3 8 6 5 9 1 5 3 2 6 8 8 5 3
    2 2 7 9 3 3 2 8 6 9 8 4 4 9 5 8 2 6 3 4 8 4 9 3 8 8
   7 7 7 9 7 5 2 7 9 2 5 1 9 2 6 5 3 9 3 5 7 3 5 4 2 8 9
  7 7 6 6 8 7 5 5 8 2 4 7 7 4 7 2 6 9 2 1 8 2 9 8 5 7 3 6
 5 9 4 5 5 7 5 5 6 3 5 3 9 5 8 9 5 4 1 2 6 1 4 3 5 3 2 4 1
X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X 
```

其中的数字代表金属块的重量（计量单位较大）。
最下一层的X代表30台极高精度的电子秤。假设每块原料的重量都十分精确地平均落在下方的两个金属块上，最后，所有的金属块的重量都严格精确地平分落在最底层的电子秤上。电子秤的计量单位很小，所以显示的数字很大。
工作人员发现，其中读数最小的电子秤的示数为：2086458231
请你推算出：读数最大的电子秤的示数为多少？
注意：需要提交的是一个整数，不要填写任何多余的内容。
**题目分析**
该题目就是一个模拟题，就是数据量偏大，使用 long long int类型来计算就可。提供官方代码
**题目代码**

```
#include <iostream>
#include <algorithm>
#include <stdio.h>
using namespace std;
#include<cmath> 
typedef long long LL;

LL arr[30][30];
int main(int argc, const char * argv[]) {
    LL factor=1;
    for (int i = 0; i < 30; ++i) {
        factor<<=1;
    }

    for (int i = 0; i < 29; ++i) {
        for (int j = 0; j <= i; ++j) {
            LL a=0;
            scanf("%lld",&a);
            arr[i][j]=a*factor;
        }
    }

    for (int i = 0; i < 29; ++i) {
        for (int j = 0; j <=i ; ++j) {
            LL ha =arr[i][j]/2;
            arr[i+1][j]+=ha;
            arr[i+1][j+1]+=ha;
        }
    }

    sort(arr[29],arr[29]+30);
    cout<<arr[29][0]/2<<","<<arr[29][29]/2<<endl;
    return 0;
} 
```

**题目答案**

```
2086458231,72665192664 
```

### 第四题：方格分割（17分）

**题目描述**
6x6的方格，沿着格子的边线剪开成两部分。
要求这两部分的形状完全相同。
如图：p1.png, p2.png, p3.png 就是可行的分割法
![在这里插入图片描述](img/fc54c5809a777a50a1d33cb8fb567f8d.png)
试计算：
包括这3种分法在内，一共有多少种不同的分割方法。
注意：旋转对称的属于同一种分割法。
请提交该整数，不要填写任何多余的内容或说明文字。

**题目分析**
从整张图的中心点出发， 每当一边切割一下时，相对的另一边也要切割相对的一下，当到达边界时候，就会对称，注意最后出来的结果要除以4，应为有4次重复。
**题目代码**

```
#include<iostream>
using namespace std;

int vis[10][10] = {0};
int dir[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};

int ans = 0;

void DFS(int x,int y)
{
	if(!x || !y || x==6 || y==6)
	{
		ans++;
		return ;
	}
	for(int i = 0; i < 4; i++)
	{
		int tempx = x + dir[i][0];
		int tempy = y + dir[i][1];
		if(!vis[tempx][tempy])
		{
			vis[tempx][tempy] = 1;
			vis[6-tempx][6 - tempy] = 1;
			DFS(tempx,tempy);
			vis[tempx][tempy] = 0;
			vis[6-tempx][6 - tempy] = 0;
		}
	}
}
int main()
{
	vis[3][3] = 1;
	DFS(3,3);
	cout << ans/4 <<endl;
	return 0;
} 
```

**题目答案**

```
509 
```

### 第五题：取数位（9分）

**题目描述**
求1个整数的第k位数字有很多种方法。
以下的方法就是一种。

```
 int len(int x){
	if(x<10) return 1;
	return len(x/10)+1;
}

int f(int x, int k){
	if(len(x)-k==0) return x%10;
	return _____________________;  
}

int main()
{
	int x = 23574;
	printf("%d\n", f(x,3));
	return 0;
} 
```

对于题目中的测试数据，应该打印5。
请仔细分析源码，并补充划线部分所缺少的代码。
注意：只提交缺失的代码，不要填写任何已有内容或说明性的文字。

**题目分析**
首先判断填入的应该是递归类型，然后依次x除以10,表示将前几位去掉，知道最后达到对应位值时候，跳出循环。
**题目代码**

```
#include<iostream>
#include<stdio.h> 
using namespace std;

int len(int x){
	if(x<10) return 1;
	return len(x/10)+1;
}

int f(int x, int k){
	if(len(x)-k==0) return x%10;
	return f(x/10,k);  
}

int main()
{
	int x = 23574;
	printf("%d\n", f(x,3));
	return 0;
} 
```

**题目答案**

```
f(x/10,k) 
```

### 第六题：最大公共子串（11分）

**题目描述**
最大公共子串长度问题就是：
求两个串的所有子串中能够匹配上的最大长度是多少。
比如：“abcdkkk” 和 “baabcdadabc”，
可以找到的最长的公共子串是"abcd",所以最大公共子串长度为4。
下面的程序是采用矩阵法进行求解的，这对串的规模不大的情况还是比较有效的解法。
请分析该解法的思路，并补全划线部分缺失的代码。

```
#include <stdio.h>
#include <string.h>

#define N 256
int f(const char* s1, const char* s2)
{
	int a[N][N];
	int len1 = strlen(s1);
	int len2 = strlen(s2);
	int i,j;

	memset(a,0,sizeof(int)*N*N);
	int max = 0;
	for(i=1; i<=len1; i++){
		for(j=1; j<=len2; j++){
			if(s1[i-1]==s2[j-1]) {
				a[i][j] = a[i-1][j-1]+1;;  
				if(a[i][j] > max) max = a[i][j];
			}
		}
	}

	return max;
}

int main()
{
	printf("%d\n", f("abcdkkk", "baabcdadabc"));
	return 0;
} 
```

注意：只提交缺少的代码，不要提交已有的代码和符号。也不要提交说明性文字。

**题目分析**
这题是一道比较经典的DP问题，具体的话可以看相关资料，后期有时间我也会写出对应的解析
**题目代码**

```
#include <stdio.h>
#include <string.h>

#define N 256
int f(const char* s1, const char* s2)
{
	int a[N][N];
	int len1 = strlen(s1);
	int len2 = strlen(s2);
	int i,j;

	memset(a,0,sizeof(int)*N*N);
	int max = 0;
	for(i=1; i<=len1; i++){
		for(j=1; j<=len2; j++){
			if(s1[i-1]==s2[j-1]) {
				a[i][j] = a[i-1][j-1]+1;  
				if(a[i][j] > max) max = a[i][j];
			}
		}
	}

	return max;
}

int main()
{
	printf("%d\n", f("abcdkkk", "baabcdadabc"));
	return 0;
} 
```

**题目答案**

```
a[i][j] = a[i-1][j-1]+1; 
```

### 第七题：日期问题（19分）

**题目描述**
小明正在整理一批历史文献。这些历史文献中出现了很多日期。小明知道这些日期都在1960年1月1日至2059年12月31日。令小明头疼的是，这些日期采用的格式非常不统一，有采用年/月/日的，有采用月/日/年的，还有采用日/月/年的。更加麻烦的是，年份也都省略了前两位，使得文献上的一个日期，存在很多可能的日期与其对应。
比如02/03/04，可能是2002年03月04日、2004年02月03日或2004年03月02日。
给出一个文献上的日期，你能帮助小明判断有哪些可能的日期对其对应吗？
输入
一个日期，格式是"AA/BB/CC"。 (0 <= A, B, C <= 9)
输出
输出若干个不相同的日期，每个日期一行，格式是"yyyy-MM-dd"。多个日期按从早到晚排列。

样例输入
02/03/04
样例输出
2002-03-04
2004-02-03
2004-03-02

资源约定：
峰值内存消耗（含虚拟机） < 256M
CPU消耗 < 1000ms

**题目分析**
先根据已经情况列举出所有可能日期，然后进行日期合法性筛选，最后对这些日期进行排序。题目题解来自[这位博主](https://blog.csdn.net/luoluozlb/article/details/72806297)
**题目代码**

```
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

typedef struct{
    int year, month, day;
}date;

bool isyn(int y){
    return (y % 4 == 0) || (y % 100 && y % 400 == 0);
}

void print(const date &d){
    printf("%02d-%02d-%02d\n", d.year, d.month, d.day);
}

bool compare(const date &d1, const date &d2){
    if(d1.year != d2.year){
        return d1.year < d2.year;
    }
    if(d1.month != d2.month){
        return d1.month < d2.month;
    }
    return d1.day < d2.day;
}

bool check(const date &d){
    static int month_days[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    if(isyn(d.year)){
        month_days[2] = 29;
    }else{
        month_days[2] = 28;
    }

    if(d.year < 1960 || d.year > 2059){
        return false;
    }
    if(d.month < 1 || d.month > 12){
        return false;
    }
    if(d.day < 1 || d.day > month_days[d.month]){
        return false;
    }
}

int main()
{
    int aa, bb, cc;
    scanf("%d/%d/%d", &aa, &bb, &cc);
    date d[6] = {
        {2000 + aa, bb, cc},
        {1900 + aa, bb, cc},
        {2000 + cc, aa, bb},
        {1900 + cc, aa, bb},
        {2000 + cc, bb, aa},
        {1900 + cc, bb, aa}
    };
    sort(d, d + 6, compare);
    for(int i = 0; i < 6; ++ i){
        if(check(d[i])){
            print(d[i]);
        }
    }
    return 0;
} 
```

### 第八题：包子凑数（21分）

**题目描述**
小明几乎每天早晨都会在一家包子铺吃早餐。他发现这家包子铺有N种蒸笼，其中第i种蒸笼恰好能放Ai个包子。每种蒸笼都有非常多笼，可以认为是无限笼。

每当有顾客想买X个包子，卖包子的大叔就会迅速选出若干笼包子来，使得这若干笼中恰好一共有X个包子。比如一共有3种蒸笼，分别能放3、4和5个包子。当顾客想买11个包子时，大叔就会选2笼3个的再加1笼5个的（也可能选出1笼3个的再加2笼4个的）。

当然有时包子大叔无论如何也凑不出顾客想买的数量。比如一共有3种蒸笼，分别能放4、5和6个包子。而顾客想买7个包子时，大叔就凑不出来了。

小明想知道一共有多少种数目是包子大叔凑不出来的。

输入
第一行包含一个整数N。(1 <= N <= 100)
以下N行每行包含一个整数Ai。(1 <= Ai <= 100)

输出
一个整数代表答案。如果凑不出的数目有无限多个，输出INF。

例如，
输入：
2
4
5

程序应该输出：
6

再例如，
输入：
2
4
6

程序应该输出：
INF

样例解释：
对于样例1，凑不出的数目包括：1, 2, 3, 6, 7, 11。
对于样例2，所有奇数都凑不出来，所以有无限多个。

资源约定：
峰值内存消耗（含虚拟机） < 256M
CPU消耗 < 1000ms

**题目分析**
**题目代码**

### 第九题：分巧克力（23分）

**题目描述**
儿童节那天有K位小朋友到小明家做客。小明拿出了珍藏的巧克力招待小朋友们。
小明一共有N块巧克力，其中第i块是Hi x Wi的方格组成的长方形。
为了公平起见，小明需要从这 N 块巧克力中切出K块巧克力分给小朋友们。切出的巧克力需要满足：
1\. 形状是正方形，边长是整数
2\. 大小相同
例如一块6x5的巧克力可以切出6块2x2的巧克力或者2块3x3的巧克力。
当然小朋友们都希望得到的巧克力尽可能大，你能帮小Hi计算出最大的边长是多少么？
输入
第一行包含两个整数N和K。(1 <= N, K <= 100000)
以下N行每行包含两个整数Hi和Wi。(1 <= Hi, Wi <= 100000)
输入保证每位小朋友至少能获得一块1x1的巧克力。
输出
输出切出的正方形巧克力最大可能的边长。

样例输入：
2 10
6 5
5 6
样例输出：
2
资源约定：
峰值内存消耗（含虚拟机） < 256M
CPU消耗 < 1000ms

**题目分析**
**题目代码**

### 第十题：k倍区间（25分）

**题目描述**
给定一个长度为N的数列，A1, A2, … AN，如果其中一段连续的子序列Ai, Ai+1, … Aj(i <= j)之和是K的倍数，我们就称这个区间[i, j]是K倍区间。
你能求出数列中总共有多少个K倍区间吗？
输入
第一行包含两个整数N和K。(1 <= N, K <= 100000)
以下N行每行包含一个整数Ai。(1 <= Ai <= 100000)
输出
输出一个整数，代表K倍区间的数目。

例如，
输入：
5 2
1
2
3
4
5
程序应该输出：
6
资源约定：
峰值内存消耗（含虚拟机） < 256M
CPU消耗 < 2000ms
**题目分析**
**题目代码**